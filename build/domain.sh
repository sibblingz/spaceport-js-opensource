#!/bin/bash

set -e -E -o pipefail

if [ "$#" -ne 3 ]; then
	echo "Usage: $0 projectRoot domain outputFile.js"
	echo
	echo "domain and outputFile.js must be relative to project root (not cwd/fsroot)"
	echo "i.e. they must be (approximately) module strings"
fi

PROJECT_ROOT="$1"
DOMAIN_ROOT="$2"
OUTPUT_FILE="$3"

FILES="$(cd "$PROJECT_ROOT" && find "$DOMAIN_ROOT" -name '*.js' -print | sort -f -b -d)"

function lines_to_array {
	# Wrap lines in quotes with trailing comma
	awk '{ print "\"" $0 "\"," }' |
	# Remove comma of last line
	sed -e '$s_,$__'
}

CLASS_DEP_STRINGS="$(echo "$FILES" |
	# Kill .js
	sed -e 's_.js$__' |
	lines_to_array
)"

CLASS_FQNS="$(echo "$FILES" |
	# Kill .js, and replace / with .
	sed -e 's_.js$__' -e 's_/_._g' |
	# Replace last . with ::
	sed -e 's_^\(.*\)\._\1::_' |
	lines_to_array
)"

MODULE_STRING="$(echo "$OUTPUT_FILE" |
	# Kill .js
	sed -e 's_.js$__' |
	lines_to_array
)"

DOMAIN_NAME_STRING="$(echo "$DOMAIN_ROOT" |
	# Kill .js, and replace / with .
	sed -e 's_/_._g' |
	lines_to_array
)"

cat > "$PROJECT_ROOT/$OUTPUT_FILE" <<EOF
// THIS FILE IS AUTOMATICALLY GENERATED FROM domain.sh
// DO NOT MODIFY MANUALLY!

define($MODULE_STRING, [
	'domain/Domain',
	$CLASS_DEP_STRINGS
], function(Domain) {
	var fqns = [
		$CLASS_FQNS
	];

	var args = arguments;

	var myDomain = new Domain($DOMAIN_NAME_STRING);
	fqns.forEach(function(fqn, index) {
		// 1 matches number of manual dependencies
		myDomain.classes[fqn] = args[index + 1];
	});

	return myDomain;
});

EOF
